--
-- XC_FQS
--
-- This file contains tests for Fast Query Shipping (FQS) for queries involving
-- a single table
-- Testset 1 for distributed table (by roundrobin)
select create_table_nodes('tab1_rr(val int, val2 int)', '{1, 2, 3}'::int[], 'roundrobin', NULL);
 create_table_nodes 
--------------------
 
(1 row)

insert into tab1_rr values (1, 2);
insert into tab1_rr values (2, 4);
insert into tab1_rr values (5, 3);
insert into tab1_rr values (7, 8);
insert into tab1_rr values (9, 2);
explain (costs off, verbose on, nodes off, num_nodes on) insert into tab1_rr values (9, 2);
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: (9), (2)
   Remote query: INSERT INTO public.tab1_rr (val, val2) VALUES (9, 2)
(3 rows)

-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (costs off, verbose on, nodes off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_rr where val2 = 4;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_rr.val, ((tab1_rr.val2 + 2)), (CASE tab1_rr.val WHEN tab1_rr.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END)
   Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM public.tab1_rr WHERE (val2 = 4)
(3 rows)

-- should get FQSed even within a subquery
select * from (select * from tab1_rr where val2 = 4) t1;
 val | val2 
-----+------
   2 |    4
(1 row)

explain (costs off, verbose on, nodes off)
	select * from (select * from tab1_rr where val2 = 4) t1;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: t1.val, t1.val2
   Remote query: SELECT val, val2 FROM (SELECT tab1_rr.val, tab1_rr.val2 FROM public.tab1_rr WHERE (tab1_rr.val2 = 4)) t1
(3 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_rr;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (costs off, verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_rr;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.sum((sum(tab1_rr.val))), pg_catalog.avg((avg(tab1_rr.val))), pg_catalog.count(*)
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (sum(tab1_rr.val)), (avg(tab1_rr.val)), (count(*))
         Remote query: SELECT sum(val), avg(val), count(*) FROM ONLY public.tab1_rr WHERE true
(5 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_rr;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (costs off, verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_rr;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 WindowAgg
   Output: first_value(tab1_rr.val) OVER (?), tab1_rr.val, tab1_rr.val2
   ->  Sort
         Output: tab1_rr.val, tab1_rr.val2
         Sort Key: tab1_rr.val2, tab1_rr.val
         ->  Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
               Output: tab1_rr.val, tab1_rr.val2
               Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE true
(8 rows)

-- should not get FQSed because of LIMIT clause
select * from tab1_rr where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val2 = 3 limit 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Limit
   Output: tab1_rr.val, tab1_rr.val2
   ->  Data Node Scan on "__REMOTE_LIMIT_QUERY__"
         Output: tab1_rr.val, tab1_rr.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE (val2 = 3) LIMIT 1::bigint
(5 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_rr where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val2 = 4 offset 1;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Limit
   Output: tab1_rr.val, tab1_rr.val2
   ->  Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
         Output: tab1_rr.val, tab1_rr.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE (val2 = 4)
(5 rows)

-- should not get FQSed because of SORT clause
select * from tab1_rr order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (costs off, verbose on, nodes off) select * from tab1_rr order by val;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort
   Output: tab1_rr.val, tab1_rr.val2
   Sort Key: tab1_rr.val
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_rr.val, tab1_rr.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE true ORDER BY 1
(6 rows)

-- should not get FQSed because of DISTINCT clause
select distinct val, val2 from tab1_rr where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select distinct val, val2 from tab1_rr where val2 = 8;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 HashAggregate
   Output: tab1_rr.val, tab1_rr.val2
   ->  Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
         Output: tab1_rr.val, tab1_rr.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE (val2 = 8)
(5 rows)

-- should not get FQSed because of GROUP clause
select val, val2 from tab1_rr where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select val, val2 from tab1_rr where val2 = 8 group by val, val2;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_rr.val, tab1_rr.val2
   Remote query: SELECT val, val2 FROM public.tab1_rr WHERE (val2 = 8) GROUP BY val, val2
(3 rows)

-- should not get FQSed because of presence of aggregates and HAVING clause,
select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (costs off, verbose on, nodes off) select sum(val) from tab1_rr where val2 = 2 group by val2 having sum(val) > 1;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: pg_catalog.sum((sum(tab1_rr.val))), tab1_rr.val2
   Filter: (pg_catalog.sum((sum(tab1_rr.val))) > 1)
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (sum(tab1_rr.val)), tab1_rr.val2
         Remote query: SELECT sum(val), val2 FROM ONLY public.tab1_rr WHERE (val2 = 2) GROUP BY 2
(6 rows)

-- tests for node reduction by application of quals, for roundrobin node
-- reduction is not applicable. Having query not FQSed because of existence of ORDER BY,
-- implies that nodes did not get reduced.
select * from tab1_rr where val = 7;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val = 7;
                              QUERY PLAN                              
----------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_rr.val, tab1_rr.val2
   Remote query: SELECT val, val2 FROM public.tab1_rr WHERE (val = 7)
(3 rows)

select * from tab1_rr where val = 7 or val = 2 order by val;
 val | val2 
-----+------
   2 |    4
   7 |    8
(2 rows)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val = 7 or val = 2 order by val;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_rr.val, tab1_rr.val2
   Sort Key: tab1_rr.val
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_rr.val, tab1_rr.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE ((val = 7) OR (val = 2)) ORDER BY 1
(6 rows)

select * from tab1_rr where val = 7 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val = 7 and val2 = 8 order by val;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
   Output: tab1_rr.val, tab1_rr.val2
   Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE ((val = 7) AND (val2 = 8))
(3 rows)

select * from tab1_rr where val = 3 + 4 and val2 = 8 order by val;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val = 3 + 4 order by val;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
   Output: tab1_rr.val, tab1_rr.val2
   Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE (val = 7)
(3 rows)

select * from tab1_rr where val = char_length('len')+4 order by val;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_rr where val = char_length('len')+4 order by val;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
   Output: tab1_rr.val, tab1_rr.val2
   Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE (val = 7)
(3 rows)

-- insert some more values 
insert into tab1_rr values (7, 2); 
select avg(val) from tab1_rr where val = 7;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (costs off, verbose on, nodes off) select avg(val) from tab1_rr where val = 7;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.avg((avg(tab1_rr.val)))
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (avg(tab1_rr.val))
         Remote query: SELECT avg(val) FROM ONLY public.tab1_rr WHERE (val = 7)
(5 rows)

select val, val2 from tab1_rr where val = 7 order by val2;
 val | val2 
-----+------
   7 |    2
   7 |    8
(2 rows)

explain (costs off, verbose on, nodes off) select val, val2 from tab1_rr where val = 7 order by val2;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Sort
   Output: tab1_rr.val, tab1_rr.val2
   Sort Key: tab1_rr.val2
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_rr.val, tab1_rr.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_rr WHERE (val = 7) ORDER BY 2
(6 rows)

select distinct val2 from tab1_rr where val = 7;
 val2 
------
    8
    2
(2 rows)

explain (costs off, verbose on, nodes off) select distinct val2 from tab1_rr where val = 7;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 HashAggregate
   Output: tab1_rr.val2
   ->  Data Node Scan on tab1_rr "_REMOTE_TABLE_QUERY_"
         Output: tab1_rr.val2
         Remote query: SELECT val2 FROM ONLY public.tab1_rr WHERE (val = 7)
(5 rows)

-- DMLs
update tab1_rr set val2 = 1000 where val = 7; 
explain (costs off, verbose on, nodes off) update tab1_rr set val2 = 1000 where val = 7; 
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (1000), (1000), tab1_rr.ctid, tab1_rr.xc_node_id
   Remote query: UPDATE public.tab1_rr SET val2 = 1000 WHERE (val = 7)
(3 rows)

select * from tab1_rr where val = 7;
 val | val2 
-----+------
   7 | 1000
   7 | 1000
(2 rows)

delete from tab1_rr where val = 7; 
explain (costs off, verbose on, nodes off) delete from tab1_rr where val = 7; 
                         QUERY PLAN                         
------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_rr.val, tab1_rr.ctid, tab1_rr.xc_node_id
   Remote query: DELETE FROM public.tab1_rr WHERE (val = 7)
(3 rows)

select * from tab1_rr where val = 7;
 val | val2 
-----+------
(0 rows)

-- Testset 2 for distributed tables (by hash)
select create_table_nodes('tab1_hash(val int, val2 int)', '{1, 2, 3}'::int[], 'hash(val)', NULL);
 create_table_nodes 
--------------------
 
(1 row)

insert into tab1_hash values (1, 2);
insert into tab1_hash values (2, 4);
insert into tab1_hash values (5, 3);
insert into tab1_hash values (7, 8);
insert into tab1_hash values (9, 2);
explain (costs off, verbose on, nodes off) insert into tab1_hash values (9, 2);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (9), (2)
   Node expr: 9
   Remote query: INSERT INTO public.tab1_hash (val, val2) VALUES (9, 2)
(4 rows)

-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (costs off, verbose on, nodes off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_hash where val2 = 2;
                                                                                        QUERY PLAN                                                                                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, ((tab1_hash.val2 + 2)), (CASE tab1_hash.val WHEN tab1_hash.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END)
   Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM public.tab1_hash WHERE (val2 = 2)
(3 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_hash;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (costs off, verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_hash;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.sum((sum(tab1_hash.val))), pg_catalog.avg((avg(tab1_hash.val))), pg_catalog.count(*)
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (sum(tab1_hash.val)), (avg(tab1_hash.val)), (count(*))
         Remote query: SELECT sum(val), avg(val), count(*) FROM ONLY public.tab1_hash WHERE true
(5 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_hash;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (costs off, verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_hash;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 WindowAgg
   Output: first_value(tab1_hash.val) OVER (?), tab1_hash.val, tab1_hash.val2
   ->  Sort
         Output: tab1_hash.val, tab1_hash.val2
         Sort Key: tab1_hash.val2, tab1_hash.val
         ->  Data Node Scan on tab1_hash "_REMOTE_TABLE_QUERY_"
               Output: tab1_hash.val, tab1_hash.val2
               Remote query: SELECT val, val2 FROM ONLY public.tab1_hash WHERE true
(8 rows)

-- should not get FQSed because of LIMIT clause
select * from tab1_hash where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_hash where val2 = 3 limit 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Limit
   Output: tab1_hash.val, tab1_hash.val2
   ->  Data Node Scan on "__REMOTE_LIMIT_QUERY__"
         Output: tab1_hash.val, tab1_hash.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_hash WHERE (val2 = 3) LIMIT 1::bigint
(5 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_hash where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (costs off, verbose on, nodes off) select * from tab1_hash where val2 = 4 offset 1;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: tab1_hash.val, tab1_hash.val2
   ->  Data Node Scan on tab1_hash "_REMOTE_TABLE_QUERY_"
         Output: tab1_hash.val, tab1_hash.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_hash WHERE (val2 = 4)
(5 rows)

-- should not get FQSed because of SORT clause
select * from tab1_hash order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (costs off, verbose on, nodes off) select * from tab1_hash order by val;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Sort
   Output: tab1_hash.val, tab1_hash.val2
   Sort Key: tab1_hash.val
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_hash.val, tab1_hash.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_hash WHERE true ORDER BY 1
(6 rows)

-- should get FQSed because of DISTINCT clause with distribution column in it
select distinct val, val2 from tab1_hash where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select distinct val, val2 from tab1_hash where val2 = 8;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT DISTINCT val, val2 FROM public.tab1_hash WHERE (val2 = 8)
(3 rows)

-- should get FQSed because of GROUP clause with distribution column in it
select val, val2 from tab1_hash where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select val, val2 from tab1_hash where val2 = 8 group by val, val2;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT val, val2 FROM public.tab1_hash WHERE (val2 = 8) GROUP BY val, val2
(3 rows)

-- should not get FQSed because of DISTINCT clause
select distinct on (val2) val, val2 from tab1_hash where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select distinct on (val2) val, val2 from tab1_hash where val2 = 8;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Unique
   Output: tab1_hash.val, tab1_hash.val2
   ->  Data Node Scan on tab1_hash "_REMOTE_TABLE_QUERY_"
         Output: tab1_hash.val, tab1_hash.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_hash WHERE (val2 = 8)
(5 rows)

-- should not get FQSed because of presence of aggregates and HAVING clause
-- withour distribution column in GROUP BY clause
select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (costs off, verbose on, nodes off) select sum(val) from tab1_hash where val2 = 2 group by val2 having sum(val) > 1;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: pg_catalog.sum((sum(tab1_hash.val))), tab1_hash.val2
   Filter: (pg_catalog.sum((sum(tab1_hash.val))) > 1)
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (sum(tab1_hash.val)), tab1_hash.val2
         Remote query: SELECT sum(val), val2 FROM ONLY public.tab1_hash WHERE (val2 = 2) GROUP BY 2
(6 rows)

-- tests for node reduction by application of quals. Having query FQSed because of
-- existence of ORDER BY, implies that nodes got reduced.
select * from tab1_hash where val = 7;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_hash where val = 7;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT val, val2 FROM public.tab1_hash WHERE (val = 7)
(3 rows)

select * from tab1_hash where val = 7 or val = 2 order by val;
 val | val2 
-----+------
   2 |    4
   7 |    8
(2 rows)

explain (costs off, verbose on, nodes off) select * from tab1_hash where val = 7 or val = 2 order by val;
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_hash.val, tab1_hash.val2
   Sort Key: tab1_hash.val
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_hash.val, tab1_hash.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_hash WHERE ((val = 7) OR (val = 2)) ORDER BY 1
(6 rows)

select * from tab1_hash where val = 7 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_hash where val = 7 and val2 = 8;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT val, val2 FROM public.tab1_hash WHERE ((val = 7) AND (val2 = 8))
(3 rows)

select * from tab1_hash where val = 3 + 4 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_hash where val = 3 + 4;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT val, val2 FROM public.tab1_hash WHERE (val = (3 + 4))
(3 rows)

select * from tab1_hash where val = char_length('len')+4;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_hash where val = char_length('len')+4;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT val, val2 FROM public.tab1_hash WHERE (val = (char_length('len'::text) + 4))
(3 rows)

-- insert some more values 
insert into tab1_hash values (7, 2); 
select avg(val) from tab1_hash where val = 7;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select avg(val) from tab1_hash where val = 7;
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: (avg(tab1_hash.val))
   Remote query: SELECT pg_catalog.int8_avg(avg(val)) AS avg FROM public.tab1_hash WHERE (val = 7)
(3 rows)

select val, val2 from tab1_hash where val = 7 order by val2;
 val | val2 
-----+------
   7 |    2
   7 |    8
(2 rows)

explain (costs off, verbose on, nodes off, num_nodes on) select val, val2 from tab1_hash where val = 7 order by val2;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.val2
   Remote query: SELECT val, val2 FROM public.tab1_hash WHERE (val = 7) ORDER BY val2
(3 rows)

select distinct val2 from tab1_hash where val = 7;
 val2 
------
    8
    2
(2 rows)

explain (costs off, verbose on, nodes off, num_nodes on) select distinct val2 from tab1_hash where val = 7;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val2
   Remote query: SELECT DISTINCT val2 FROM public.tab1_hash WHERE (val = 7)
(3 rows)

-- FQS for subqueries
select * from (select avg(val) from tab1_hash where val = 7) t1;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on)
	select * from (select avg(val) from tab1_hash where val = 7) t1;
                                                                 QUERY PLAN                                                                 
--------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: t1.avg
   Remote query: SELECT avg FROM (SELECT pg_catalog.int8_avg(avg(tab1_hash.val)) AS avg FROM public.tab1_hash WHERE (tab1_hash.val = 7)) t1
(3 rows)

-- DMLs
update tab1_hash set val2 = 1000 where val = 7; 
explain (costs off, verbose on, nodes off) update tab1_hash set val2 = 1000 where val = 7; 
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (1000), (1000), tab1_hash.ctid, tab1_hash.xc_node_id
   Remote query: UPDATE public.tab1_hash SET val2 = 1000 WHERE (val = 7)
(3 rows)

select * from tab1_hash where val = 7;
 val | val2 
-----+------
   7 | 1000
   7 | 1000
(2 rows)

delete from tab1_hash where val = 7; 
explain (costs off, verbose on, nodes off) delete from tab1_hash where val = 7; 
                          QUERY PLAN                           
---------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_hash.val, tab1_hash.ctid, tab1_hash.xc_node_id
   Remote query: DELETE FROM public.tab1_hash WHERE (val = 7)
(3 rows)

select * from tab1_hash where val = 7;
 val | val2 
-----+------
(0 rows)

-- Testset 3 for distributed tables (by modulo)
select create_table_nodes('tab1_modulo(val int, val2 int)', '{1, 2, 3}'::int[], 'modulo(val)', NULL);
 create_table_nodes 
--------------------
 
(1 row)

insert into tab1_modulo values (1, 2);
insert into tab1_modulo values (2, 4);
insert into tab1_modulo values (5, 3);
insert into tab1_modulo values (7, 8);
insert into tab1_modulo values (9, 2);
explain (costs off, verbose on, nodes off) insert into tab1_modulo values (9, 2);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (9), (2)
   Node expr: 9
   Remote query: INSERT INTO public.tab1_modulo (val, val2) VALUES (9, 2)
(4 rows)

-- simple select
-- should get FQSed
select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
 val | ?column? |           case            
-----+----------+---------------------------
   2 |        6 | val and val2 are not same
(1 row)

explain (costs off, verbose on, nodes off) select val, val2 + 2, case val when val2 then 'val and val2 are same' else 'val and val2 are not same' end from tab1_modulo where val2 = 4;
                                                                                         QUERY PLAN                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, ((tab1_modulo.val2 + 2)), (CASE tab1_modulo.val WHEN tab1_modulo.val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END)
   Remote query: SELECT val, (val2 + 2), CASE val WHEN val2 THEN 'val and val2 are same'::text ELSE 'val and val2 are not same'::text END AS "case" FROM public.tab1_modulo WHERE (val2 = 4)
(3 rows)

-- should not get FQSed because of aggregates
select sum(val), avg(val), count(*) from tab1_modulo;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (costs off, verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_modulo;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: pg_catalog.sum((sum(tab1_modulo.val))), pg_catalog.avg((avg(tab1_modulo.val))), pg_catalog.count(*)
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (sum(tab1_modulo.val)), (avg(tab1_modulo.val)), (count(*))
         Remote query: SELECT sum(val), avg(val), count(*) FROM ONLY public.tab1_modulo WHERE true
(5 rows)

-- should not get FQSed because of window functions
select first_value(val) over (partition by val2 order by val) from tab1_modulo;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (costs off, verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_modulo;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 WindowAgg
   Output: first_value(tab1_modulo.val) OVER (?), tab1_modulo.val, tab1_modulo.val2
   ->  Sort
         Output: tab1_modulo.val, tab1_modulo.val2
         Sort Key: tab1_modulo.val2, tab1_modulo.val
         ->  Data Node Scan on tab1_modulo "_REMOTE_TABLE_QUERY_"
               Output: tab1_modulo.val, tab1_modulo.val2
               Remote query: SELECT val, val2 FROM ONLY public.tab1_modulo WHERE true
(8 rows)

-- should not get FQSed because of LIMIT clause
select * from tab1_modulo where val2 = 3 limit 1;
 val | val2 
-----+------
   5 |    3
(1 row)

explain (costs off, verbose on, nodes off) select * from tab1_modulo where val2 = 3 limit 1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: tab1_modulo.val, tab1_modulo.val2
   ->  Data Node Scan on "__REMOTE_LIMIT_QUERY__"
         Output: tab1_modulo.val, tab1_modulo.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_modulo WHERE (val2 = 3) LIMIT 1::bigint
(5 rows)

-- should not FQSed because of OFFSET clause
select * from tab1_modulo where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (costs off, verbose on, nodes off) select * from tab1_modulo where val2 = 4 offset 1;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Limit
   Output: tab1_modulo.val, tab1_modulo.val2
   ->  Data Node Scan on tab1_modulo "_REMOTE_TABLE_QUERY_"
         Output: tab1_modulo.val, tab1_modulo.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_modulo WHERE (val2 = 4)
(5 rows)

-- should not get FQSed because of SORT clause
select * from tab1_modulo order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (costs off, verbose on, nodes off) select * from tab1_modulo order by val;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Sort
   Output: tab1_modulo.val, tab1_modulo.val2
   Sort Key: tab1_modulo.val
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_modulo.val, tab1_modulo.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_modulo WHERE true ORDER BY 1
(6 rows)

-- should get FQSed because of DISTINCT clause with distribution column in it
select distinct val, val2 from tab1_modulo where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select distinct val, val2 from tab1_modulo where val2 = 8;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT DISTINCT val, val2 FROM public.tab1_modulo WHERE (val2 = 8)
(3 rows)

-- should get FQSed because of GROUP clause with distribution column in it
select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select val, val2 from tab1_modulo where val2 = 8 group by val, val2;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT val, val2 FROM public.tab1_modulo WHERE (val2 = 8) GROUP BY val, val2
(3 rows)

-- should not get FQSed because of DISTINCT clause without distribution column
-- in it
select distinct on (val2) val, val2 from tab1_modulo where val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off) select distinct on (val2) val, val2 from tab1_modulo where val2 = 8;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Unique
   Output: tab1_modulo.val, tab1_modulo.val2
   ->  Data Node Scan on tab1_modulo "_REMOTE_TABLE_QUERY_"
         Output: tab1_modulo.val, tab1_modulo.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_modulo WHERE (val2 = 8)
(5 rows)

-- should not get FQSed because of presence of aggregates and HAVING clause
-- without distribution column in GROUP BY clause
select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
 sum 
-----
  10
(1 row)

explain (costs off, verbose on, nodes off) select sum(val) from tab1_modulo where val2 = 2 group by val2 having sum(val) > 1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 GroupAggregate
   Output: pg_catalog.sum((sum(tab1_modulo.val))), tab1_modulo.val2
   Filter: (pg_catalog.sum((sum(tab1_modulo.val))) > 1)
   ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
         Output: (sum(tab1_modulo.val)), tab1_modulo.val2
         Remote query: SELECT sum(val), val2 FROM ONLY public.tab1_modulo WHERE (val2 = 2) GROUP BY 2
(6 rows)

-- tests for node reduction by application of quals. Having query FQSed because of
-- existence of ORDER BY, implies that nodes got reduced.
select * from tab1_modulo where val = 7;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_modulo where val = 7;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT val, val2 FROM public.tab1_modulo WHERE (val = 7)
(3 rows)

select * from tab1_modulo where val = 7 or val = 2 order by val;
 val | val2 
-----+------
   2 |    4
   7 |    8
(2 rows)

explain (costs off, verbose on, nodes off) select * from tab1_modulo where val = 7 or val = 2 order by val;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Sort
   Output: tab1_modulo.val, tab1_modulo.val2
   Sort Key: tab1_modulo.val
   ->  Data Node Scan on "__REMOTE_SORT_QUERY__"
         Output: tab1_modulo.val, tab1_modulo.val2
         Remote query: SELECT val, val2 FROM ONLY public.tab1_modulo WHERE ((val = 7) OR (val = 2)) ORDER BY 1
(6 rows)

select * from tab1_modulo where val = 7 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_modulo where val = 7 and val2 = 8;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT val, val2 FROM public.tab1_modulo WHERE ((val = 7) AND (val2 = 8))
(3 rows)

select * from tab1_modulo where val = 3 + 4 and val2 = 8;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_modulo where val = 3 + 4;
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT val, val2 FROM public.tab1_modulo WHERE (val = (3 + 4))
(3 rows)

select * from tab1_modulo where val = char_length('len')+4;
 val | val2 
-----+------
   7 |    8
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select * from tab1_modulo where val = char_length('len')+4;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT val, val2 FROM public.tab1_modulo WHERE (val = (char_length('len'::text) + 4))
(3 rows)

-- insert some more values 
insert into tab1_modulo values (7, 2); 
select avg(val) from tab1_modulo where val = 7;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on) select avg(val) from tab1_modulo where val = 7;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: (avg(tab1_modulo.val))
   Remote query: SELECT pg_catalog.int8_avg(avg(val)) AS avg FROM public.tab1_modulo WHERE (val = 7)
(3 rows)

select val, val2 from tab1_modulo where val = 7 order by val2;
 val | val2 
-----+------
   7 |    2
   7 |    8
(2 rows)

explain (costs off, verbose on, nodes off, num_nodes on) select val, val2 from tab1_modulo where val = 7 order by val2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.val2
   Remote query: SELECT val, val2 FROM public.tab1_modulo WHERE (val = 7) ORDER BY val2
(3 rows)

select distinct val2 from tab1_modulo where val = 7;
 val2 
------
    8
    2
(2 rows)

explain (costs off, verbose on, nodes off, num_nodes on) select distinct val2 from tab1_modulo where val = 7;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val2
   Remote query: SELECT DISTINCT val2 FROM public.tab1_modulo WHERE (val = 7)
(3 rows)

-- FQS for subqueries
select * from (select avg(val) from tab1_modulo where val = 7) t1;
        avg         
--------------------
 7.0000000000000000
(1 row)

explain (costs off, verbose on, nodes off, num_nodes on)
	select * from (select avg(val) from tab1_modulo where val = 7) t1;
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: t1.avg
   Remote query: SELECT avg FROM (SELECT pg_catalog.int8_avg(avg(tab1_modulo.val)) AS avg FROM public.tab1_modulo WHERE (tab1_modulo.val = 7)) t1
(3 rows)

-- DMLs
update tab1_modulo set val2 = 1000 where val = 7; 
explain (costs off, verbose on, nodes off) update tab1_modulo set val2 = 1000 where val = 7; 
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (1000), (1000), tab1_modulo.ctid, tab1_modulo.xc_node_id
   Remote query: UPDATE public.tab1_modulo SET val2 = 1000 WHERE (val = 7)
(3 rows)

select * from tab1_modulo where val = 7;
 val | val2 
-----+------
   7 | 1000
   7 | 1000
(2 rows)

delete from tab1_modulo where val = 7; 
explain (costs off, verbose on, nodes off) delete from tab1_modulo where val = 7; 
                             QUERY PLAN                              
---------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_modulo.val, tab1_modulo.ctid, tab1_modulo.xc_node_id
   Remote query: DELETE FROM public.tab1_modulo WHERE (val = 7)
(3 rows)

select * from tab1_modulo where val = 7;
 val | val2 
-----+------
(0 rows)

-- Testset 4 for replicated tables, for replicated tables, unless the expression
-- is itself unshippable, any query involving a single replicated table is shippable
select create_table_nodes('tab1_replicated(val int, val2 int)', '{1, 2, 3}'::int[], 'replication', NULL);
 create_table_nodes 
--------------------
 
(1 row)

insert into tab1_replicated values (1, 2);
insert into tab1_replicated values (2, 4);
insert into tab1_replicated values (5, 3);
insert into tab1_replicated values (7, 8);
insert into tab1_replicated values (9, 2);
explain (costs off, verbose on, nodes off) insert into tab1_replicated values (9, 2);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (9), (2)
   Remote query: INSERT INTO public.tab1_replicated (val, val2) VALUES (9, 2)
(3 rows)

-- simple select
select * from tab1_replicated;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select * from tab1_replicated;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM public.tab1_replicated
(3 rows)

select sum(val), avg(val), count(*) from tab1_replicated;
 sum |        avg         | count 
-----+--------------------+-------
  24 | 4.8000000000000000 |     5
(1 row)

explain (costs off, num_nodes on, verbose on, nodes off) select sum(val), avg(val), count(*) from tab1_replicated;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: (sum(tab1_replicated.val)), (avg(tab1_replicated.val)), (count(*))
   Remote query: SELECT sum(val) AS sum, pg_catalog.int8_avg(avg(val)) AS avg, count(*) AS count FROM public.tab1_replicated
(3 rows)

select first_value(val) over (partition by val2 order by val) from tab1_replicated;
 first_value 
-------------
           1
           1
           5
           2
           7
(5 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select first_value(val) over (partition by val2 order by val) from tab1_replicated;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: (first_value(tab1_replicated.val) OVER (?)), tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT first_value(val) OVER (PARTITION BY val2 ORDER BY val) AS first_value FROM public.tab1_replicated
(3 rows)

select * from tab1_replicated where val2 = 2 limit 2;
 val | val2 
-----+------
   1 |    2
   9 |    2
(2 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select * from tab1_replicated where val2 = 2 limit 2;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM public.tab1_replicated WHERE (val2 = 2) LIMIT 2
(3 rows)

select * from tab1_replicated where val2 = 4 offset 1;
 val | val2 
-----+------
(0 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select * from tab1_replicated where val2 = 4 offset 1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM public.tab1_replicated WHERE (val2 = 4) OFFSET 1
(3 rows)

select * from tab1_replicated order by val;
 val | val2 
-----+------
   1 |    2
   2 |    4
   5 |    3
   7 |    8
   9 |    2
(5 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select * from tab1_replicated order by val;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM public.tab1_replicated ORDER BY val
(3 rows)

select distinct val, val2 from tab1_replicated;
 val | val2 
-----+------
   9 |    2
   5 |    3
   1 |    2
   2 |    4
   7 |    8
(5 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select distinct val, val2 from tab1_replicated;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT DISTINCT val, val2 FROM public.tab1_replicated
(3 rows)

select val, val2 from tab1_replicated group by val, val2;
 val | val2 
-----+------
   9 |    2
   5 |    3
   1 |    2
   2 |    4
   7 |    8
(5 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select val, val2 from tab1_replicated group by val, val2;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.val2
   Remote query: SELECT val, val2 FROM public.tab1_replicated GROUP BY val, val2
(3 rows)

select sum(val) from tab1_replicated group by val2 having sum(val) > 1;
 sum 
-----
   7
   2
   5
  10
(4 rows)

explain (costs off, num_nodes on, verbose on, nodes off) select sum(val) from tab1_replicated group by val2 having sum(val) > 1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: (sum(tab1_replicated.val)), tab1_replicated.val2
   Remote query: SELECT sum(val) AS sum FROM public.tab1_replicated GROUP BY val2 HAVING (sum(val) > 1)
(3 rows)

-- FQS for subqueries
select * from (select sum(val), val2 from tab1_replicated group by val2 order by val2) t1;
 sum | val2 
-----+------
  10 |    2
   5 |    3
   2 |    4
   7 |    8
(4 rows)

explain (costs off, verbose on, nodes off, num_nodes on)
	select * from (select sum(val), val2 from tab1_replicated group by val2 order by val2) t1;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Data Node Scan (primary node count=0, node count=1) on "__REMOTE_FQS_QUERY__"
   Output: t1.sum, t1.val2
   Remote query: SELECT sum, val2 FROM (SELECT sum(tab1_replicated.val) AS sum, tab1_replicated.val2 FROM public.tab1_replicated GROUP BY tab1_replicated.val2 ORDER BY tab1_replicated.val2) t1
(3 rows)

-- DMLs
update tab1_replicated set val2 = 1000 where val = 7; 
explain (costs off, verbose on, nodes off) update tab1_replicated set val2 = 1000 where val = 7; 
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: (1000), (1000), tab1_replicated.ctid
   Remote query: UPDATE public.tab1_replicated SET val2 = 1000 WHERE (val = 7)
(3 rows)

select * from tab1_replicated where val = 7;
 val | val2 
-----+------
   7 | 1000
(1 row)

delete from tab1_replicated where val = 7; 
explain (costs off, verbose on, nodes off) delete from tab1_replicated where val = 7; 
                             QUERY PLAN                             
--------------------------------------------------------------------
 Data Node Scan on "__REMOTE_FQS_QUERY__"
   Output: tab1_replicated.val, tab1_replicated.ctid
   Remote query: DELETE FROM public.tab1_replicated WHERE (val = 7)
(3 rows)

select * from tab1_replicated where val = 7;
 val | val2 
-----+------
(0 rows)

drop table tab1_rr;
drop table tab1_hash;
drop table tab1_modulo;
drop table tab1_replicated;
